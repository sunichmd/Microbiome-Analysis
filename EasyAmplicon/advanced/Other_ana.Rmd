# adonism分析
```{r}
data=read.csv("AROs_Relative_abundance.xls", header=TRUE, row.names=1,sep = "\t",check.names = F)
metadata = read.table("metadata.txt",sep="\t",row.names = 1,header = T)
metadata$g = metadata$Group
metadata = metadata[colnames(data),]
library(vegan)
anosim=anosim(t(data), metadata$Group)
summary(anosim)
pdf("anosim.pdf")
plot(anosim, col = sample(colors(),7))
dev.off()

sink("anosim_Result.txt")
summary(anosim)
sink()
```

# PCA分析
```{r}
datExpr = log2(data+1)
PCA  <-  prcomp(t(datExpr), scale = FALSE)
percentVar  <-  round(100*PCA$sdev^2/sum(PCA$sdev^2),1)
sd_ratio  <-  sqrt(percentVar[2] / percentVar[1])
dataGG  <-  data.frame(PC1 = PCA$x[,1], PC2 = PCA$x[,2],
                     group =metadata$Group)

p = ggplot(dataGG, aes(PC1, PC2)) +
  geom_point(aes(colour = group)) +
  ggtitle("PCA plot") +
  xlab(paste0("PC1, VarExp: ", percentVar[1], "%")) +
  ylab(paste0("PC2, VarExp: ", percentVar[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5)) +
  coord_fixed(1) + scale_shape_manual(values = c(4,15)) + theme_bw() +
  theme(panel.grid=element_blank(),panel.border=element_blank(),axis.line=element_line(size=1,colour="black"))
pca_result = summary(PCA)$importance
write.table(pca_result,"PCA_result.csv",sep=",",quote = F,col.names = T,row.names = T)
write.table(PCA$x,"gene_in_PC.csv",sep=",",quote = F,col.names = T,row.names = T)
ggsave(plot=p,filename="PCA_plot.pdf",height = 5)

```

# lefse分析

```{bash}
ENV_lefse=~/anaconda3/envs/lefse
source activate ${ENV_lefse};export PATH=${ENV_lefse}/bin/:$PATH
lefse-format_input.py lefse.txt input.in -c 1 -o 1000000
run_lefse.py input.in input.res
lefse-plot_res.py input.res res.pdf --format pdf
```

```{r}
library(microbiomeViz)
library(ggtree)
library(tidyverse)
library(phyloseq)
library(MASS)

df = read.csv("lefse.txt",sep="\t",header=T,check.names=F,row.names = 1)
dat <- data.frame(V1=df[,1], V2=rowMeans(df[,-1]), stringsAsFactors = FALSE)

# 数据问题1,在g__Clostridium不同的科下面都出现；没注释的最开始最后就别加进来；为什么会有这么多重复数据
# duplicate row.names: s__, g__Clostridium
# remove duplicat rownames
# dat_re = dat %>% distinct(V1, .keep_all = TRUE)
# re_row = c(grep("g__Clostridium",dat_re$V1),grep("g__|s__",dat_re$V1))
# df_no_dup = df[df$group %in% dat_re[-re_row,]$V1,]

# 计算差异物种
dat3 = df
claslbl = rownames(df)
dat3t = t(dat3)
rawpvalues <- apply(dat3t, 2, function(x) kruskal.test(x, claslbl)$p.value);

#--得到计算后得到的p值
ord.inx <- order(rawpvalues);
rawpvalues <- rawpvalues[ord.inx];
clapvalues <- p.adjust(rawpvalues, method ="fdr");
# p.adjust
dat3t <- dat3t[,ord.inx];
dim(dat3t)

wil_datadf <- as.data.frame(dat3t);
wil_datadf$claslbl = claslbl
write.table(t(wil_datadf[,sp][,-gn]),"lefse1.txt",sep="\t",quote=F)

# 过滤不符合lda计算要求的数据
gn = dim(wil_datadf)[2]
x=as.matrix(wil_datadf[,-gn])
p <- ncol(x)
n <- nrow(x)
g <- as.factor(wil_datadf[,gn])
group.means <- tapply(c(x), list(rep(g, p), col(x)), mean)
f1 <- sqrt(diag(var(x - group.means[g,  ])))
sp = names(f1[f1>=1e-4])

# 过滤不符合lda计算要求的数据
gn = dim(wil_datadf)[2]
x=as.matrix(wil_datadf[,-gn])
p <- ncol(x)
n <- nrow(x)
g <- as.factor(wil_datadf[,gn])
group.means <- tapply(c(x), list(rep(g, p), col(x)), mean)
f1 <- sqrt(diag(var(x - group.means[g,  ])))
sp = names(f1[f1>=1e-4])
write.table(t(wil_datadf[,sp][,-gn]),"lefse1.txt",sep="\t",quote=F)
```

```{r}
# 计算lda值
ldares <- lda(wil_datadf[,sp][,-gn],grouping=wil_datadf[,gn]);

# ldares
ldamean <- as.data.frame(t(ldares$means));
# ldamean
class_no <<- length(unique(claslbl));
ldamean$max <- apply(ldamean[,1:class_no],1,max);
ldamean$min <- apply(ldamean[,1:class_no],1,min);

#计算LDA
ldamean$LDAscore <- signif(log10(1+abs(ldamean$max-ldamean$min)/2),digits=3);

a = rep("A",length(ldamean$max))
i = 1
for (i in 1:length(ldamean$max)) {
	name =colnames(ldamean[,1:class_no])
	a[i] = name[ldamean[,1:class_no][i,] %in% ldamean$max[i]]
}
ldamean$class = a
# head(ldamean)

ldamean$Pvalues <- signif(rawpvalues[sp],digits=5);
ldamean$FDR <- signif(clapvalues[sp],digits=5);
resTable <- ldamean;
# head(ldamean)
# it seems lda add ` around names containing dash "-", need to strip this off
rawNms <- rownames(resTable);
rownames(resTable) <- gsub("`", '', rawNms);
# head(resTable)
# if(pvalOpt == "raw"){
#   de.Num <- sum(rawpvalues<=p.lvl & ldamean$LDAscore>=lda.lvl)
# }else{
p.lvl =0.5
lda.lvl = 1e-6
de.Num <- sum(clapvalues[sp]<=p.lvl & ldamean$LDAscore>=lda.lvl)
# }

if(de.Num == 0){
	current.msg <<- "No significant features were identified with given criteria.";
}else{
	current.msg <<- paste("A total of", de.Num, "significant features with given criteria.")
}
current.msg
# sort by p value
ord.inx <- order(resTable$Pvalues, resTable$LDAscore);
resTable <- resTable[ord.inx, ,drop=FALSE];
#p-values column to appear first; then FDR and then others
resTable <- resTable[,c(ncol(resTable),1:(ncol(resTable)-1))];
resTable <- resTable[,c(ncol(resTable),1:(ncol(resTable)-1))];

write.csv(resTable,"cs.csv")

taxtree = resTable[clapvalues[sp]<=p.lvl & ldamean$LDAscore>=lda.lvl,]

delimiter = "\\|"
tax_split <- strsplit(row.names(taxtree), delimiter)
row.names(taxtree)<- vapply(tax_split, tail, n = 1, "")

# head(taxtree)

#-提取所需要的颜色
colour = c('darkgreen','red',"blue")

selececol = colour[1:length(levels(as.factor(taxtree$class)))]

names(selececol) = levels(as.factor(taxtree$class))
A = rep("a",length(row.names(taxtree)))

i = 1
for (i in 1:length(row.names(taxtree))) {
	A[i] = selececol [taxtree$class[i]]
}

# A

lefse_lists = data.frame(node=row.names(taxtree),
						 color=A,
						 stringsAsFactors = FALSE
)

# str(all)

## 计算均值用于呈现结点大小
dat <- data.frame(V1=df[,1], V2=rowMeans(df[,-1]), stringsAsFactors = FALSE)

# head(dat)
# dim(dat)
# write.csv(dat,"./tree_tax.csv")

# 用物种和丰度生成树骨架
tr <- parseMetaphlanTSV(dat_re[-re_row,][dat_re[-re_row,]$V1 %in% sp,], node.size.offset=2, node.size.scale=0.8)
p <- tree.backbone(tr, size=0.5)

# 注释树

p <- clade.anno(p, lefse_lists, alpha=0.3)

ggsave("./cs.pdf",p,width = 10,height = 10)

```

## R计算
```{bash}
ENV_lefse=~/anaconda3/envs/lefse
source activate ${ENV_lefse};export PATH=${ENV_lefse}/bin/:$PATH
lefse-format_input.py lefse.txt input.in -c 1 -o 1000000
run_lefse.py input.in input.res
lefse-plot_res.py input.res res.pdf --format pdf
```

```{r}
library(microbiomeViz)
library(ggtree)
library(tidyverse)
library(phyloseq)
library(MASS)

df = read.csv("f4.txt",sep="\t",header=T,check.names=F,row.names = 1)
dat <- data.frame(V1=df[,1], V2=rowMeans(df[,-1]), stringsAsFactors = FALSE)

# 计算差异物种
dat3 = df
claslbl = rownames(df)
dat3t = t(dat3)
rawpvalues <- apply(dat3t, 2, function(x) kruskal.test(x, claslbl)$p.value);

#--得到计算后得到的p值
ord.inx <- order(rawpvalues);
rawpvalues <- rawpvalues[ord.inx];
clapvalues <- p.adjust(rawpvalues, method ="fdr");
# p.adjust
dat3t <- dat3t[,ord.inx];
dim(dat3t)

wil_datadf <- as.data.frame(dat3t);
wil_datadf$claslbl = claslbl

# 过滤不符合lda计算要求的数据
gn = dim(wil_datadf)[2]
x=as.matrix(wil_datadf[,-gn])
p <- ncol(x)
n <- nrow(x)
g <- as.factor(wil_datadf[,gn])
group.means <- tapply(c(x), list(rep(g, p), col(x)), mean)
f1 <- sqrt(diag(var(x - group.means[g,  ])))
sp = names(f1[f1>=1e-4])
write.table(t(wil_datadf[,sp][,-gn]),"lefse1.txt",sep="\t",quote=F)
```

# 三元相图
#### 差异分析
```{bash}
db=/d/public
mkdir -p S_type/compare/
    # 输入特征表、元数据；指定分组列名、比较组和丰度
    # 选择方法wilcox/t.test/edgeR、PValue和PValue和输出目录
compare="mesotrophic-oligotrophic"
Rscript ${db}/script/compare.R \
      --input S_table.txt --design  S_type/meta_S.txt \
      --group Group3 --compare ${compare} --threshold 0 \
      --method edgeR -p 0.05 -f 0.2 \
      --output S_type/compare/
      
compare="oligotrophic-mesotrophic"
Rscript ${db}/script/compare.R \
      --input S_table.txt --design  S_type/meta_S.txt \
      --group Group3 --compare ${compare} --threshold 0 \
      --method edgeR -p 0.05 -f 0.2 \
      --output S_type/compare/
      
compare="mesotrophic-eutrophic"
Rscript ${db}/script/compare.R \
      --input S_table.txt --design  S_type/meta_S.txt \
      --group Group3 --compare ${compare} --threshold 0 \
      --method edgeR -p 0.05 -f 0.2 \
      --output S_type/compare/
      
compare="eutrophic-mesotrophic"
Rscript ${db}/script/compare.R \
      --input S_table.txt --design  S_type/meta_S.txt \
      --group Group3 --compare ${compare} --threshold 0 \
      --method edgeR -p 0.05 -f 0.2 \
      --output S_type/compare/
      
compare="oligotrophic-eutrophic"
Rscript ${db}/script/compare.R \
      --input S_table.txt --design  S_type/meta_S.txt \
      --group Group3 --compare ${compare} --threshold 0 \
      --method edgeR -p 0.05 -f 0.2 \
      --output S_type/compare/
      
compare="eutrophic-oligotrophic"
Rscript ${db}/script/compare.R \
      --input S_table.txt --design  S_type/meta_S.txt \
      --group Group3 --compare ${compare} --threshold 0 \
      --method edgeR -p 0.05 -f 0.2 \
      --output S_type/compare/
```

#### 整理
```{r}
group = "Group3"
dir = "S_type/compare/"
sub_design = read.table("S_type/meta_S.txt",sep="\t",header=T,row.names = 1)

otu_table =read.table("S_table.txt",header = T, row.names = 1,comment.char = "")
rownames(otu_table) = paste0("X",rownames(otu_table))

#View(head(otu_table))

dat = otu_table[,rownames(sub_design)]

count = dat
norm= as.data.frame(t(t(count)/colSums(count))*100)
## 按样品名合并实验组与转置的OTU
mat_t2 = merge(sub_design[c("Group3")], t(norm), by="row.names")[,-1]
  #write.table("OTUID\t", file="test.txt",append = F, quote = F, eol = "", row.names = F, col.names = F)
  #write.table(mat_t2,"test.txt",append = F,quote = F,sep = '\t',row.names = F)
```


```{r}
## 按实验设计求组平均值
View(mat_t2[1:6,1:6])
mat_mean = aggregate(mat_t2[,-1], by=mat_t2[1], FUN=mean) # mean 
View(head(mat_mean[1:3,1:3]))
```

#### 画三元图
```{r}
per3 = data.frame(t(mat_mean[,-1]))
colnames(per3) = mat_mean[[group]]
j=72
n = 0.1
fc_thre = 2
print(dim(as.data.frame(per3[rowSums(per3)>n,])))
per3 = as.data.frame(per3[rowSums(per3)>n,]) # remove all 0 OTU

# 样本的比例的
if(F){
	# per3$size <- "in <10% samples"
	# per3$size[apply(mat_t2[,rownames((per3))],2,function(x) length(which(x!=0)))/  nrow(mat_t2) >0.1] <- "in 10% samples"
	# per3$size[apply(mat_t2[,rownames((per3))],2,function(x) length(which(x!=0)))/  nrow(mat_t2) >0.3] <- "in 30% samples"
	# per3$size[apply(mat_t2[,rownames((per3))],2,function(x) length(which(x!=0)))/  nrow(mat_t2) >0.5] <- "in 50% samples"
	# per3$size = factor(per3$size,levels = c("in <10% samples","in 10% samples","in 30% samples","in 50% samples"))
	per3$size <- 1
	per3$size[apply(mat_t2[,rownames((per3))],2,function(x) length(which(x!=0)))/  nrow(mat_t2) >n] <- 2
	per3$size[apply(mat_t2[,rownames((per3))],2,function(x) length(which(x!=0)))/  nrow(mat_t2) >n+0.3] <- 3
	per3$size[apply(mat_t2[,rownames((per3))],2,function(x) length(which(x!=0)))/  nrow(mat_t2) >n+0.3*2] <- 4
	table(per3$size)
}

if(T){
	# per3$size <- "in <10% samples"
	# per3$size[apply(mat_t2[,rownames((per3))],2,function(x) length(which(x!=0)))/  nrow(mat_t2) >0.1] <- "in 10% samples"
	# per3$size[apply(mat_t2[,rownames((per3))],2,function(x) length(which(x!=0)))/  nrow(mat_t2) >0.3] <- "in 30% samples"
	# per3$size[apply(mat_t2[,rownames((per3))],2,function(x) length(which(x!=0)))/  nrow(mat_t2) >0.5] <- "in 50% samples"
	# per3$size = factor(per3$size,levels = c("in <10% samples","in 10% samples","in 30% samples","in 50% samples"))
	per3$size <- apply(norm[rownames(per3),],1,mean)
}else{
	per3$size<-apply(per3[,1:3],1,mad)
}

tern = c("oligotrophic","mesotrophic","eutrophic")
per3 = per3[,c(tern,"size")] # reorder per3 as input
color = c("#5CB85CFF","#BC80BD","#D95F02","#B4B4B4B3")
per3$color = color[4]
per3$Group = "Nosig"

## select A specific
  AvB = read.csv(paste(dir,tern[1],"-",tern[2],".txt",sep=""), header=T, row.names= 1, sep="\t")
  AvB = subset(AvB,AvB$PValue<0.05& AvB$log2FC>fc_thre)
  AvC = read.csv(paste(dir,tern[1],"-",tern[3],".txt",sep=""), header=T, row.names= 1, sep="\t")
  AvC = subset(AvC,AvC$PValue<0.05& AvC$log2FC>fc_thre)
  A = unique(c(row.names(AvB), row.names(AvC)))
  #A = rownames(subset(AvB,AvB$PValue<0.05&AvB$log2FC!=0))
  length(A)
  A = paste0("X",A)
 
## select B specific
  
  BvA = read.csv(paste(dir,tern[2],"-",tern[1],".txt",sep=""), header=T, row.names= 1, sep="\t")
  BvA = subset(BvA,BvA$PValue<0.05&BvA$log2FC>fc_thre)
  BvC = read.csv(paste(dir,tern[2],"-",tern[3],".txt",sep=""), header=T, row.names= 1, sep="\t")
  BvC = subset(BvC,BvC$PValue<0.05&BvC$log2FC>fc_thre)
  B = unique(c(row.names(BvA), row.names(BvC)))
  #B = rownames(subset(BvC,BvC$PValue<0.05&BvC$log2FC!=0))
  length(B)
  B = paste0("X",B)
  
## select C specific
  CvA = read.csv(paste(dir,tern[3],"-",tern[1],".txt",sep=""), header=T, row.names= 1, sep="\t")
  CvA = subset(CvA,CvA$PValue<0.05&CvA$log2FC>fc_thre)
  CvB = read.csv(paste(dir,tern[3],"-",tern[2],".txt",sep=""), header=T, row.names= 1, sep="\t")
  CvB = subset(CvB,CvB$PValue<0.05&CvB$log2FC>fc_thre)
  C = unique(c(row.names(CvA), row.names(CvB)))
  #C = rownames(subset(CvA,CvA$PValue<0.05&CvA$log2FC!=0))
  length(C)
  C = paste0("X",C)
  
  venn_diff = intersect(intersect(A,B),C)
  A_B = intersect(A,B)
  B_C = intersect(B,C)
  A_C = intersect(A,C)
  all_diff = unique(c(intersect(A,B),intersect(A,C),intersect(B,C)))
  #all_diff = c()
  
  # View(head(per3))
  # View(per3[A,])
  
  if (length(A)!=0&&length(A[!A%in%all_diff])!=0){per3[A[!A%in%all_diff],]$color=color[1]} 
	if (length(A)!=0&&length(A[!A%in%all_diff])!=0){per3[A[!A%in%all_diff],]$Group=tern[1]} # set all default
	table(per3$Group)
	if (length(B)!=0&&length(B[!B%in%all_diff])!=0){per3[B[!B%in%all_diff],]$color=color[2]} # set all default
	if (length(B)!=0&&length(B[!B%in%all_diff])!=0){per3[B[!B%in%all_diff],]$Group=tern[2]} 
	table(per3$Group)
	if (length(C)!=0&&length(C[!C%in%all_diff])!=0){per3[C[!C%in%all_diff],]$color=color[3]}
	if (length(C)!=0&&length(C[!C%in%all_diff])!=0){per3[C[!C%in%all_diff],]$Group=tern[3]}
	
  if(F){
		color2 = c("#CCEBC5","#8DA0CB","#E5C494")
		if (length(A_B)!=0){per3[A_B,]$color=color2[1]}
		if (length(A_B)!=0){per3[A_B,]$Group=paste0(tern[1]," & ",tern[2])}
		
		if (length(B_C)!=0){per3[B_C,]$color=color2[2]}
		if (length(B_C)!=0){per3[B_C,]$Group=paste0(tern[2]," & ",tern[3])}
		
		if (length(A_C)!=0){per3[A_C,]$color=color2[3]}
		if (length(A_C)!=0){per3[A_C,]$Group=paste0(tern[1]," & ",tern[3])}
  #per3[,1:3]=log2(per3[,1:3]*1+1) #per3[,1:3]=log2(per3[,1:3]*1)
  }
 

  tax = read.table("tax.txt",sep="\t",header = T,row.names = 1)
	rownames(tax) = paste0("X",rownames(tax))
	per3_na = na.omit(per3)
	table(per3_na$Group)
	table(per3_na$color)
  table(per3_na$size)

  per3f <- merge(per3_na,tax,by="row.names",all.x = T)
  library(stringr)
  per3f$phylum = gsub("p__","",str_split(per3f$Taxon,"; ",simplify = T)[,2])
  per3f$class = gsub("c__","",str_split(per3f$Taxon,"; ",simplify = T)[,3])
  per3f$order = gsub("o__","",str_split(per3f$Taxon,"; ",simplify = T)[,4])
  per3f$family = gsub("f__","",str_split(per3f$Taxon,"; ",simplify = T)[,5])
  per3f$genus = gsub("g__","",str_split(per3f$Taxon,"; ",simplify = T)[,6])
  rownames(per3f)<-per3f$Row.names
  
   ##第一种
    ##or per3f[[tern[1]]],per3f[[tern[2]]],per3f[[tern[3]]]
    # p=ggtern(per3f,aes(get(tern[1]),get(tern[2]),get(tern[3])))+
    #   geom_point(aes(size=mad,color=Group), alpha = 0.7,show.legend = TRUE)+
    #   scale_size(range = c(0, 6))+theme_bw() +theme(axis.ticks = element_blank())+
    #   Llab(paste0(tern[1],"(",length(A),")"))+Tlab(paste0(tern[2],"(",length(B),")"))+
    #   Rlab(paste0(tern[3],"(",length(C),")"))
  library(scales)
    if(length(A)==0&length(B)==0&length(C)==0){
    	sink(file=paste0(dir,"noSig_tern.txt"),append = T);print(paste0(tern[1],"、",tern[2],"、",tern[3],"no sig"))
    	}else{
    # print(head(per3f))
    # print(tern)
    library(ggtern)
    library(vcd)
    		
    per3f_n = subset(per3f,Group=="Nosig")
    per3f_s = subset(per3f,Group!="Nosig")
    #per3f=per3f[which(per3f$Group!="Nosig"),]
    	
    pdf(file=paste0(dir,tern[1],"_",tern[2],"_",tern[3],".pdf"),width=11,height=7)
    print(ggtern(per3f,
    				 aes(x=per3f[[tern[1]]],y=per3f[[tern[2]]],z=per3f[[tern[3]]],size=size)) +
    	geom_mask() +
      geom_point(data = per3f_n,
      					 aes(x=per3f_n[[tern[1]]],y=per3f_n[[tern[2]]],z=per3f_n[[tern[3]]]),
      					 color=per3f_n$color,alpha = 1) +
    	geom_point(data = per3f_s, 
    						 aes(x=per3f_s[[tern[1]]],y=per3f_s[[tern[2]]],z=per3f_s[[tern[3]]]),
    						 color=per3f_s$color,alpha = 1,show.legend=T) + # 通过两个point让有颜色的在上面
      #scale_size(range = c(0.5,4))+
      Llab(paste0(tern[1],"(",table(per3f$Group)[tern[1]],")"))+
    	Tlab(paste0(tern[2],"(",table(per3f$Group)[tern[2]],")"))+
      Rlab(paste0(tern[3],"(",table(per3f$Group)[tern[3]],")"))+
    	theme_bw() +
      #geom_density_tern(aes(color=Group),bins=5)+ # 密度图
      #geom_smooth_tern(method="loess",fullrange=TRUE,colour='red')+ # 平滑曲线
      theme(title=element_text(size = 10),
      			legend.title = element_text(size=10),
      			tern.panel.expand=0.4,
      			legend.position="top")+
    	scale_size(range = c(1,6))) 
    
    legend_table = per3f_s[!duplicated(per3f_s[,c("Group","color")]),c("Group","color")]
    rownames(legend_table) = legend_table$Group
    legend_table$showname = paste0(rownames(legend_table),
    															 "(",
    															 table(per3f_s$Group)[rownames(legend_table)],
    															 ")")
    
    grid_legend(0.85, 0.7, 19,legend_table$color,legend_table$showname,
    						frame = FALSE,size=0.4,title = "Enriched")
    legend_table = per3f_s[!duplicated(per3f_s[,c("Group","color")]),c("Group","color")]
    rownames(legend_table) = legend_table$Group
    legend_table$showname = paste0(rownames(legend_table),
    															 "(",
    															 table(per3f_s$Group)[rownames(legend_table)],
    															 ")")
    
    grid_legend(0.85, 0.7, 19,legend_table$color,legend_table$showname,
    						frame = FALSE,size=0.4,title = "Enriched")
    dev.off()
    
    library(RColorBrewer)
		qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
		col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))) 
		col_vector = col_vector[!col_vector%in%c("#666666","#CCCCCC","#F2F2F2","#999999","#B3B3B3","#D9D9D9","#F1E2CC")]
		show_col(col_vector)
    for(tax in c("genus","family","order","class","phylum")){
    	if(length(unique(per3f[[tax]])) < 66){
		    set.seed(j);bar_fill_color = sample(col_vector, length(unique(per3f[[tax]])), replace = FALSE)
    	}else{
		  	color433 = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
		  	bar_fill_color = sample(color433, length(unique(per3f[[tax]])), replace = FALSE)
		  }
    pdf(file=paste0(dir,tern[1],"_",tern[2],"_",tern[3],"_",tax,".pdf"),width=15,height=7)
    print(ggtern(per3f,
    				 aes(x=per3f[[tern[1]]],y=per3f[[tern[2]]],z=per3f[[tern[3]]])) +
    	geom_mask() +
      geom_point(data = per3f_n,
      					 aes(x=per3f_n[[tern[1]]],y=per3f_n[[tern[2]]],z=per3f_n[[tern[3]]],size=size),
      					 color="grey",alpha = 1) +
    	geom_point(data = per3f_s, 
    						 aes(x=per3f_s[[tern[1]]],y=per3f_s[[tern[2]]],z=per3f_s[[tern[3]]],color=.data[[tax]],size=size),
    						 alpha = 1,show.legend=T) + # 通过两个point让有颜色的在上面
      Llab(paste0(tern[1],"(",table(per3f$Group)[tern[1]],")"))+
    	Tlab(paste0(tern[2],"(",table(per3f$Group)[tern[2]],")"))+
      Rlab(paste0(tern[3],"(",table(per3f$Group)[tern[3]],")"))+
    	theme_bw() +
    	scale_color_manual(name = tax,values = bar_fill_color,guide=guide_legend(reverse=T))+
      #geom_density_tern(aes(color=Group),bins=5)+ # 密度图
      #geom_smooth_tern(method="loess",fullrange=TRUE,colour='red')+ # 平滑曲线
      theme(title=element_text(size = 10),
      			legend.title = element_text(size=10),
      			legend.text = element_text(size=5),
      			tern.panel.expand=0.4,
      			legend.position="right") +
    	scale_size(range = c(1,6)))  
    
    dev.off()
    }
    
    
    #ggsave(paste0(dir,tern[1],"_",tern[2],"_",tern[3],".pdf"),p,height = 7,width=10)
    
    #write.table("sam\t", file=paste0(dir,tern[1],"_",tern[2],"_",tern[3],".txt"),append = F, quote = F, eol = "", row.names = F, col.names = F)
    #write.table(per3f,file=paste0(dir,tern[1],"_",tern[2],"_",tern[3],".txt"),append = F,quote = F,sep = '\t',row.names = F)
    }
```

#### 画复杂热图
```{r}
per3f1 = subset(per3f,per3f$Group %in% tern)
norm_sub = log10(norm[rownames(per3f1),]+1)

library(pheatmap)

anntation_col = data.frame(Group = factor(sub_design[colnames(norm_sub),"Group3"],levels=tern),
													 row.names = colnames(norm_sub))
anntation_col = anntation_col[order(anntation_col$Group),,drop=F]

anntation_row = per3f1[,c("Group","class","genus")]

colnames(anntation_row)[1] = "SigGroup"
anntation_row$SigGroup = factor(anntation_row$SigGroup,levels = tern)
anntation_row = anntation_row[order(anntation_row$SigGroup),,drop=F]

s = paste0('ann_c = list(Group = c(', tern[1], ' = "', color[1], '",',
					                    tern[2], ' = "', color[2], '",',
					                    tern[3], ' = "', color[3] ,'"),',
					           'SigGroup = c(', tern[1], ' = "', color[1], '",',
					                    tern[2], ' = "', color[2], '",',
					                    tern[3], ' = "', color[3] ,'"))')
eval(parse(text = s))

data_heat = norm_sub[rownames(anntation_row),rownames(anntation_col)]
exp <- apply(data_heat, 1, scale)
rownames(exp) <- colnames(data_heat)
exp <- t(exp)

# pheatmap::pheatmap(exp[rownames(anntation_row),rownames(anntation_col)],scale = "row",
#            #cutree_rows=2,cutree_cols = 2,
# 					 col = colorRampPalette(colors = c("#6395C7","white","#E06EAD"))(100),
# 				   annotation_colors = ann_c,
#            cluster_cols = T,
#            cluster_row = T,
#            annotation_col = anntation_col,
#            annotation_row = anntation_row,
#            filename = paste("W_type/compare_heatmap/","all_diff_heatmap.pdf", sep=""),
#            width=16, height=12,
#            annotation_names_row= T,annotation_names_col=T,
#            show_rownames=F,show_colnames=T,
#            fontsize=6,display_numbers=F,
# 				   border_color = NA
# 		   )

library(circlize)

col_fun <- colorRamp2(
  c(-5, 0, 5), 
  c("#6395C7", "white", "#E06EAD")
  )
library(ComplexHeatmap)

pdf(paste("S_type/compare_heatmap/","all_diff_heatmap_cluster_by_Group.pdf", sep=""),width = 15,height = 15)
set.seed(500);pheatmap(exp[rownames(anntation_row),rownames(anntation_col)],#表达矩阵
				scale = "row",
        col = col_fun,#颜色定义
				annotation_colors = ann_c,
        show_rownames = F,#不展示行名
				show_colnames = F,#不展示行名
        annotation_col = anntation_col,
				annotation_names_col = F ,
				cluster_cols = T,
				clustering_method = "complete",#"ward.D", "ward.D2", "single", "complete", "average" (= UPGMA), "mcquitty" (= WPGMA), "median" (= WPGMC) or "centroid" (= UPGMC).
        annotation_row = anntation_row,
        column_split = anntation_col$Group,#用group信息将热图分开，以group聚类
				row_split = anntation_row$SigGroup,
        column_title = NULL)
dev.off()

pdf(paste("S_type/compare_heatmap/","all_diff_heatmap.pdf", sep=""),width = 15,height = 15)
set.seed(500);pheatmap(exp[rownames(anntation_row),rownames(anntation_col)],#表达矩阵
				scale = "row",
        col = col_fun,#颜色定义
				annotation_colors = ann_c,
        show_rownames = F,#不展示行名
				show_colnames = F,#不展示行名
        annotation_col = anntation_col,
				annotation_names_col = F ,
				cluster_cols = F,
				clustering_method = "complete",#"ward.D", "ward.D2", "single", "complete", "average" (= UPGMA), "mcquitty" (= WPGMA), "median" (= WPGMC) or "centroid" (= UPGMC).
        annotation_row = anntation_row,
        column_split = anntation_col$Group,#用group信息将热图分开，以group聚类
				row_split = anntation_row$SigGroup,
        column_title = NULL)
dev.off()

top_annotation = HeatmapAnnotation(cluster = anno_block(gp = gpar(fill = color[1:3]),
																												labels = tern,
																												labels_gp = gpar(col = "black", fontsize = 12)))#通用代码
col_ha <- HeatmapAnnotation(
	Group = anntation_col$Group,
	col = list(Group = c("oligotrophic" =  "#5CB85CFF", "mesotrophic" = "#BC80BD", "eutrophic" = "#D95F02")))

row_ha <- rowAnnotation(
	sigGroup = anntation_row$SigGroup,
	Class = anntation_row$class,
	Genus = anntation_row$genus,
	col = list(sigGroup = c("oligotrophic" =  "#5CB85CFF", "mesotrophic" = "#BC80BD", "eutrophic" = "#D95F02")))

#pa = cluster::pam(t(exp), k = 3)
# pdf(paste("W_type/compare_heatmap/","all_diff_heatmap_cluster_by_Group.pdf", sep=""),width = 15)
# Heatmap(exp[rownames(anntation_row),rownames(anntation_col)],#表达矩阵
#         col = col_fun,#颜色定义
#         show_row_names = F,#不展示行名
#         top_annotation = col_ha,#顶部分组信息
#         column_split = anntation_col$Group,#用group信息将热图分开，以group聚类
#         column_title = NULL,#不显示列标题
# 				left_annotation = row_ha,
# 				row_split = anntation_row$SigGroup,
#         show_column_names = F,
# 				column_dend_reorder = T,
# 				column_order = rownames(anntation_col),
# 				name=" ")
# dev.off()
# 
# pdf(paste("W_type/compare_heatmap/","all_diff_heatmap_cluster_by_Group.pdf", sep=""),width = 15)
# Heatmap(exp[rownames(anntation_row),rownames(anntation_col)],#表达矩阵
#         col = col_fun,#颜色定义
#         show_row_names = F,#不展示行名
#         top_annotation = col_ha,#顶部分组信息
#         column_split = anntation_col$Group,#用group信息将热图分开，以group聚类
#         column_title = NULL,#不显示列标题
# 				left_annotation = row_ha,
# 				row_split = anntation_row$SigGroup,
#         show_column_names = F,
# 				column_dend_reorder = T,
# 				heatmap_legend_param = list(title = ""),
# 				name=" ")
# dev.off()
```

# NMDS

```{r}
library(vegan)

otu <- read.delim("result/otutab.txt", row.names = 1, sep = '\t', stringsAsFactors = FALSE, check.names = FALSE)
otu <- data.frame(t(otu))
bray_dis <- vegdist(otu, method = 'bray')

nmds_dis <- metaMDS(bray_dis, k = 2)
nmds_dis$stress
nmds_dis$stress

nmds_dis_site <- data.frame(nmds_dis$points)
nmds_dis_species <- wascores(nmds_dis$points, otu)

library(ggplot2)

#主要展示 top10 丰度物种
abundance <- apply(otu, 2, sum)
abundance_top10 <- names(abundance[order(abundance, decreasing = TRUE)][1:10])
species_top10 <- data.frame(nmds_dis_species[abundance_top10,1:2])
species_top10$name <- rownames(species_top10)

nmds_dis_site$name <- rownames(nmds_dis_site)

map<-read.table("result/metadata.txt",header=T,sep="\t",row.names=1)
#nmds_dis_site$group <- map$group
merged=merge(nmds_dis_site,map,by="row.names",all.x=TRUE)
color=c( "#3C5488B2","#00A087B2", 
                    "#F39B7FB2","#91D1C2B2", 
                    "#8491B4B2", "#DC0000B2", 
                    "#7E6148B2","yellow", 
                    "darkolivegreen1", "lightskyblue", 
                    "darkgreen", "deeppink", "khaki2", 
                    "firebrick", "brown1", "darkorange1", 
                    "cyan1", "royalblue4", "darksalmon", 
                    "darkgoldenrod1", "darkseagreen", "darkorchid")
                    #grid.col[row.names(data)] = color[1:dim(data)[1]]

p <- ggplot(data = merged, aes(MDS1, MDS2)) +
  geom_point(size=2,aes(color =  Group,shape = Group)) +
  stat_ellipse(aes(fill = Group), geom = 'polygon', level = 0.95, alpha = 0.1, show.legend = FALSE) +   #添加置信椭圆，注意不是聚类
  scale_color_manual(values =color[1:length(unique(map$Group))]) +
  scale_fill_manual(values = color[1:length(unique(map$Group))]) +
  theme(panel.grid.major = element_line(color = 'gray', size = 0.2), panel.background = element_rect(color = 'black', fill = 'transparent'), 
        plot.title = element_text(hjust = 0.5),legend.title = element_blank()) +
  #, legend.position = 'none'
  geom_vline(xintercept = 0, color = 'gray', size = 0.5) +
  geom_hline(yintercept = 0, color = 'gray', size = 0.5)+
  geom_text(data = species_top10, aes(label = name), color ="royalblue4", size = 4)+
  geom_text(data =merged, aes(label = Row.names,x =MDS1, y = MDS2), size=4, check_overlap = TRUE)


#geom_text(data = species_top10, aes(label = name), color = 'blue', size = textsize)

p

```

# 整理greengene2数据库为usearch的格式
```{bash}
# 得到greengene id 和tax的关系，并处理成usearch的格式
awk 'BEGIN{OFS=FS="\t"}FNR>1{sintax=$2";";gsub("__;","__Unassigned;",sintax);gsub("__",":",sintax);gsub("; ",",",sintax);print">"$1";tax="sintax}' 2022.10.taxonomy.id.tsv >2022.10.taxonomy.id.tax.tsv

# 把tax里的空格替换成下划线
awk '{gsub(" ","_",$0);print $0}' 2022.10.taxonomy.id.tax.tsv>2022.10.taxonomy.id.tax1.tsv

# 检查文件
## 检查换行符
grep $'\r' 2022.10.seqs.fna
sed -i 's/\r//' 2022.10.seqs.fna
## 检查文件的空行
grep --color=auto -n -C 2 -E '^$' 2022.10.seqs.fna
## 删除文件中无意义的空行
grep -v -E '^$' 2022.10.seqs.fna >2022.10.seqs.rmnull.fna
grep --color=auto -n -C 2 -E '^$' 2022.10.seqs.rmnull.fna

## 检查不完全匹配
## 当id文件没有seq的序列名时，则该条序列名则不会有tax信息了，这条序列就需要删掉，先看下有没有这类情况
## 当seq的序列名不存在id文件中时，没关系
awk 'BEGIN{OFS=FS=";"}ARGIND==1{a[$1]=$0}ARGIND==2{if($0~/>/) {if(a[$0]==""){name=$0}else{name=a[$0]};print name}else print $0}' 2022.10.taxonomy.id.tax1.tsv  2022.10.seqs.fna >  2022.10.seqs.usearch1.fna
grep ">" 2022.10.seqs.usearch1.fna|grep -v "tax"
 
## 存在不完全匹配的情况
# 把上述tax信息放进fasta文件的序列名那行,并且删除没有tax信息的序列
awk 'BEGIN{OFS=FS=";"}ARGIND==1{a[$1]=$0}ARGIND==2{if($0~/>/) {if(a[$0]==""){getline;next}else{name=a[$0];print name}}else print $0}' 2022.10.taxonomy.id.tax1.tsv  2022.10.seqs.rmnull.fna >  2022.10.seqs.usearch.fna

```

# 计算相对丰度的alpha多样性
```{r}
otutab = read.table("result/tax/sum_g.txt",row.names = 1, sep = '\t', stringsAsFactors = FALSE, check.names = FALSE,comment.char = "",header = T)

# sum_g.txt里有一列all，最后也会计算all这列的alpha多样性，可以用下面的代码把all这列删除，注释掉下面这行也行，因为画图的时候会自动跳过这个信息
otutab = otutab[,which(colnames(otutab)!="All")]

# 加载包
suppressWarnings(suppressMessages(library(vegan)))

otu=t(otutab)
# vegan::diversity计算多样性指数shannon, simpson和invsimpson
shannon = vegan::diversity(otu, index = "shannon")
simpson = vegan::diversity(otu, index = "simpson")
invsimpson = vegan::diversity(otu, index = "invsimpson")

# 只要一个asv在这个样本存在（丰度不为0），richness+1
richness = apply(otu,1,function(x){table(x!=0)["TRUE"]})

# 1-simpson是为了和usearch计算的方法一样
alpha_div = cbind(richness,shannon, 1-simpson, invsimpson)
colnames(alpha_div) = c("richness","shannon", "simpson", "invsimpson")

write.table("SampleID\t", file=paste("result/alpha/alpha_freq.txt",sep=""),append = F, quote = F, eol = "", row.names = F, col.names = F)
# 保存统计结果，有waring正常
suppressWarnings(write.table(alpha_div, file=paste("result/alpha/alpha_freq.txt",sep=""), append = T, quote = F, sep="\t", eol = "\n", na = "NA", dec = ".", row.names = T, col.names = T))
```

画图
```{bash}
for i in `head -n1 result/alpha/alpha_freq.txt|cut -f 2-`;do
Rscript ${db}/script/alpha_boxplot.R --alpha_index ${i} \
        --input result/alpha/alpha_freq.txt --design result/metadata.txt \
        --group Group --output result/alpha/freq_ \
        --width 89 --height 59
done
```

# 物种累积曲线

物种累积曲线(Species accumulation curves)与稀疏曲线类似，用于衡量和预测群落中物种丰富度随样本量扩大而增加的幅度，被广泛用于判断样本量是否足够并估计群落丰富度(Chao and Shen, 2004)。

物种累计曲线中，横坐标是样本个数，纵坐标是发现的物种个数，随着样本个数的增加，发现的物种个数也不断增加；一般来说，在样本量较少时，随着新样本的加入，将有较大可能性发现大量的新物种，此时曲线将呈现急剧上升的形态；当样本量已经较大时，此时群落中的ASV/OTU总数将不再随着新样本的加入而显著增加，曲线也将趋于平缓。因此，可以利用物种累积曲线判断样本量是否足够大：若曲线始终保持上升趋势，则表明样本量不足，需要扩大采样规模；反之，则表明样本量已足以反映群落的物种组成(建议在样本量不低于10个时分析)。

```{r}
library(vegan)

otu <- read.table('result/otutab.txt', row.names = 1, sep = '\t', stringsAsFactors = FALSE, check.names = FALSE,comment.char = "",header = T)
otu=t(otu)

set.seed(1);sp <- specaccum(otu, method = 'random')
summary(sp)

plot(sp, ci.type = 'poly', col = 'blue', lwd = 2, ci.lty = 0, ci.col = 'lightblue')
boxplot(sp, col = 'yellow', add = TRUE, pch = '+')

# 保存图形
pdf("species_acc_curv.pdf")
plot(sp, ci.type = 'poly', col = 'blue', lwd = 2, ci.lty = 0, ci.col = 'lightblue')
boxplot(sp, col = 'yellow', add = TRUE, pch = '+')
dev.off()
```

# 物种相对丰度冲积图
```{r}
## 20种颜色
color20<-c('#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4',
					 '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff',
					 '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1',
					 '#000075', '#808080', '#ffffff', '#000000')

## 79种颜色
library(RColorBrewer)
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))) 

##
library(randomcoloR)
palette <- randomColor(count = 3) #随机生成60种颜色，其实里面有重复的
palette <- distinctColorPalette(10) 

## 10种颜色
## 蓝绿调
palette = c("#A6CEE3", "#FFFF99", "#377EB8", "#D9D9D9", "#B3E2CD",
						"#CCEBC5", "#BEAED4", "#F781BF", "#F2F2F2", "#8DA0CB", "#FC8D62")
show_col(palette)
## 浅粉蓝黄
palette = c("#F781BF", "#8DD3C7", "#FBB4AE", "#B3DE69", "#CCEBC5", "#FF7F00", "#E78AC3", "#BF5B17", "#FFFF33", "#377EB8", "#D9D9D9")
palette = c("#377EB8", "#6A3D9A", "#CCEBC5", "#F1E2CC", "#4DAF4A", "#E6F5C9", "#FDDAEC", "#7FC97F", "#D95F02", "#B3B3B3", "#666666")
show_col(palette)
## 黄绿调
"#A6D854" "#999999" "#FFFFCC" "#66A61E" "#FFFF33" "#CCEBC5" "#FFFFB3" "#B2DF8A" "#F4CAE4" "#7FC97F" "#FFFF99"
library(scales)
n=10
keep=F
pn = list()
p_s = list()
for(tax in c("p","c","o","f","g")){
	for(i in c("R","S","L")){
		dir = paste0("result/",i,"/")
		
		metadata = read.table(paste0("result/metadata_",i,".txt"),header=T,sep='\t',row.names = 1)
		metadata$Time[metadata$Time=="A"] <- "1m"
		metadata$Time[metadata$Time=="B"] <- "2m"
		metadata$Time[metadata$Time=="C"] <- "3m"
		
		metadata$Treat[metadata$Treat=="CK"] <- "WM"
		metadata$Treat[metadata$Treat=="KP"] <- "MixOS"
		metadata$Treat[metadata$Treat=="PY"] <- "RT"
		
		pairdata = read.table(paste0(dir,"tax/sum_",tax,".txt"),header=T,sep='\t',row.names = 1)
		pairdata = pairdata[,rownames(metadata)]
		#pairdata = pairdata[rowSums(pairdata)>0,]
		if(T){
			pairdata = pairdata[!rownames(pairdata) %in% "Unassigned",]
		}
		# 统计topN的丰度
		if(nrow(pairdata)<n){
			n=nrow(pairdata)
			pairdata_sort = as.data.frame(t(pairdata[order(rowSums(pairdata),decreasing = T)[1:n],]))
		}else{
			if(keep==T){
				pairdata_sort_n = data.frame(t(pairdata[order(rowSums(pairdata),decreasing = T)[1:n],]))
				pairdata_sort_o = colSums(pairdata[order(rowSums(pairdata),decreasing = T)[(n+1):nrow(pairdata)],])
				pairdata_sort = cbind(pairdata_sort_n,
															pairdata_sort_o)
				colnames(pairdata_sort)[n+1] <- "Other"
				colSums(pairdata_sort)
				rowSums(pairdata_sort)
			}else{
				pairdata_sort = as.data.frame(t(pairdata[order(rowSums(pairdata),decreasing = T)[1:n],]))
			}
		}
		if(keep==F){
			pairdata_sort = pairdata_sort[rowSums(pairdata_sort)>0,]
			pairdata_sort = data.frame(t(apply(pairdata_sort,1,function(x) x/sum(x)*100)))
		}
		
		metadata$tre_time = paste0(metadata$Treat,metadata$Time)
		mat_t2 = merge(metadata[,c("Time","Treat","tre_time"),drop=F],pairdata_sort,all.y = T,by="row.names")
		mat_t2 = mat_t2[,c(-1)]
		mat_mean = aggregate(mat_t2[,-1:-3], by=mat_t2[3], FUN=mean) # mean
		mat_mean_final = merge(metadata[!duplicated(metadata$tre_time),c("Time","Treat","tre_time"),drop=F],mat_mean,by="tre_time",all.y = T)[,-1]
		plot_mat_mean = melt(mat_mean_final)
		plot_mat_mean$variable = factor(plot_mat_mean$variable,levels = rev(levels(plot_mat_mean$variable)))
		head(plot_mat_mean)
		#plot_mat_mean$variable = factor(plot_mat_mean$variable,levels = rev(levels(plot_mat_mean$variable)))
		# #set.seed(72);bar_fill_color = sample(colors(), length(levels(as.factor(plot_mat_mean$variable))), replace = FALSE)
		# #set.seed(8);bar_fill_color = sample(color20, length(levels(as.factor(plot_mat_mean$variable))), replace = FALSE)
		# #bar_fill_color = col_vector[1:length(levels(as.factor(plot_mat_mean$variable)))]
		# # palette <- randomColor(10,luminosity = c("light"))
		# # bar_fill_color = palette
		# #bar_fill_color = brewer.pal(12, "Paired")[-2]
		# #data$Term = with(plot_mat_mean,reorder(Term,Value))
		# show_col(bar_fill_color)
		# 十个浅色配
		# palette=c("#8DA0CB", "#FFF2AE", "#FBB4AE", "#FDBF6F", "#FFD92F", "#FCCDE5", "#B3CDE3", "#CAB2D6", "#B3E2CD", "#F1E2CC", "#D9D9D9")
		# 十个略深配
		# palette=c("#E6AB02", "#FC8D62", "#A6CEE3", "#386CB0", "#7FC97F", "#1B9E77", "#F0027F", "#E6F5C9", "#CCCCCC", "#B3DE69","#B3B3B3")
		set.seed(68+147456);bar_fill_color = sample(col_vector, length(levels(plot_mat_mean$variable)), replace = FALSE)
		bar_fill_color[length(bar_fill_color)] <- "#D9D9D9"
		bar_fill_color[6] <- "#8DA0CB"
		bar_fill_color[1] <- "#5CB85CFF"
		show_col(c(bar_fill_color))
		p1 = plot_mat_mean %>% ggplot(aes(x = Time, 
																			y = value/100,
																			stratum = variable, 
																			alluvium = variable,
																			fill = variable, 
																			label = variable)) + 
			ggalluvial::geom_flow(position = "identity",alpha=0.4, width = 0.6) +
			labs(x = "Group", y = "Relative abundance") +  # 绘制同类别之间的连接线
			ggalluvial::geom_stratum(position = "identity",width = 0.6,size = 0.25,color=NA) +  # 代替 geom_col() 绘制堆叠柱形图
			theme_bw() + 
			ggtitle("") + 
			scale_fill_manual(name="Taxonomy",values = rev(bar_fill_color),guide=guide_legend(reverse=F)) + 
			theme(legend.position = "right",
						plot.background = element_blank(), 
						panel.grid = element_blank()) +
			facet_wrap(.~Treat) +
			scale_y_continuous(labels = scales::percent)
		p1
		p2 = plot_mat_mean %>% ggplot(aes(x = Treat, 
																			y = value/100,
																			stratum = variable, 
																			alluvium = variable,
																			fill = variable, 
																			label = variable)) + 
			ggalluvial::geom_flow(alpha=0.4, width = 0.6) +
			labs(x = "Group", y = "Relative abundance") +  # 绘制同类别之间的连接线
			ggalluvial::geom_stratum(width = 0.6,size = 0.25,color=NA) +  # 代替 geom_col() 绘制堆叠柱形图，超过20不太好看
			theme_bw() + 
			ggtitle("") + 
			scale_fill_manual(name="Taxonomy",values = rev(bar_fill_color),guide=guide_legend(reverse=F)) + 
			theme(legend.position = "right", 
						plot.background = element_blank(), 
						panel.grid = element_blank()) +facet_wrap(.~Time) +
			scale_y_continuous(labels = scales::percent)
		
		p2
		pn[[i]] = ggarrange(p1,p2)
		
		#### 相对丰度堆积柱状图-----------
		if(T){
			# 展示样本
			if(F){
				metadata$Sample = substr(rownames(metadata),6,6)
				mat_t3 = merge(metadata[,c("Sample","Time","Treat","tre_time"),drop=F],pairdata_sort,all.x = T,by="row.names")
				mat_t3 = mat_t3[,-1]
				data_all = melt(mat_t3,id.vars = c("Time","Treat","tre_time","Sample"))
				data_all$variable = factor(data_all$variable,levels = rev(levels(plot_mat_mean$variable)))
				p = ggplot(data_all, aes(x = Sample, y = value/100, fill = variable )) +
					facet_grid(Time ~ Treat) +
					labs(x = "Group", y = "Relative abundance") +  # 绘制同类别之间的连接线
					#ggalluvial::geom_stratum(decreasing = T,width = 0.6,size = 0.25,color="black") +  # 代替 geom_col() 绘制堆叠柱形图
					geom_bar(stat = "identity",position="fill", width=1)+
					theme_bw() + 
					ggtitle("") + 
					scale_fill_manual(name="Taxonomy",values = rev(bar_fill_color)) + 
					theme(legend.position = "right",
								plot.background = element_blank(), 
								panel.grid = element_blank()) +
					
					scale_y_continuous(labels = scales::percent)
				p
			}
			plot_mat_mean1 = plot_mat_mean
			#plot_mat_mean1$variable = factor(plot_mat_mean1$variable,levels = rev(levels(plot_mat_mean$variable)))
			p_s[[i]] = ggplot(data=plot_mat_mean1,aes(x = Treat, 
																								y = value/100,
																								# stratum = variable, 
																								# alluvium = variable,
																								fill = variable)) + 
				#ggalluvial::geom_flow(decreasing = T,alpha=0.6, width = 0.6) +
				labs(x = "Group", y = "Relative abundance") +  # 绘制同类别之间的连接线
				#ggalluvial::geom_stratum(decreasing = T,width = 0.6,size = 0.25,color="black") +  # 代替 geom_col() 绘制堆叠柱形图
				geom_bar(stat = "identity",position="stack", width=0.6)+
				theme_bw() + 
				ggtitle("") + 
				scale_fill_manual(name="Taxonomy",values = rev(bar_fill_color)) + 
				theme(legend.position = "right",
							plot.background = element_blank(), 
							panel.grid = element_blank()) +
				facet_wrap(.~Time) +
				scale_y_continuous(labels = scales::percent)
			p_s[[i]]
		}
	}
	p3 = ggarrange(pn[["L"]],pn[["R"]],pn[["S"]],ncol = 1)
	p3
	p4 = ggarrange(p_s[["L"]],p_s[["R"]],p_s[["S"]],ncol = 1)
	ggsave(paste0("../result1/Fig3a_",tax,"_alluvial_plot.pdf"),p3,width = 16,height = 4*3)
	ggsave(paste0("../result1/Fig3a_",tax,"_stack_plot.pdf"),p4,width = 16-8,height = 4*3)
}

```

# svd分析
SVD用来衡量不同样本中菌群组成的变异情况，核心思想来源于奇异值分解（SVD）思想下的标准化差异统计，但这里并不是直接使用 svd() 函数，而是基于标准差来计算每个 OTU 的相对变动程度。

用于比较不同分组中样本的微生物丰度波动性（变异度），推测干扰强度或稳定性。

在微生物生态学中，如果一个处理组的菌群波动大（AVD 高），可能说明该处理对菌群的影响强烈或样本间差异大；如果 AVD 小，可能说明菌群在这个组更稳定或受干扰少。

中文：
我们基于样本微生物丰度表计算了各样本的绝对变异度（AVD），用于衡量不同处理或时间组中菌群组成的波动性。AVD 值越高，说明样本的菌群结构越不稳定或波动越大；反之则更稳定。通过分组对比，可以揭示不同处理条件对微生物群落稳定性的影响。

英文：
We computed the Absolute Variation Degree (AVD) for each sample to evaluate the fluctuation of microbial composition across different conditions. Higher AVD values indicate greater instability or perturbation in microbial communities. This analysis helps compare the community stability under various treatments or time points.

```{r}
#读取 OTU 丰度表
otu1 <- read.delim('result/otutab.txt', row.names = 1, sep = '\t', check.names = FALSE)

#读取分组，合并数据并简单可视化
group <- read.delim('../metadata_bac.txt', sep = '\t', stringsAsFactors = FALSE,
										check.names = FALSE)
group = group[c(-1:-10,-126:-130),]

otu = otu1[,group$Sample]
otu = otu[apply(otu,1,sum)>0,]
#计算各 OTU 的变异度
ai <- abs(otu-apply(otu, 1, mean))/apply(otu, 1, sd)

#由于此时计算的是单个样本的 AVD，即 k=1
avd <- colSums(ai)/(1*nrow(otu))

group$AVD <- avd
group

library(viridis)

library(ggpubr)
p=list()
# sorted_vector <- c("SDGJ1", "SDGJ2","SDGB", "SDGN",
# 	"1Y", "3YR", "4Y", "4YR", "6Y", "8Y", "9Y", 
# 	"10YQ", "11YQ", "11YM", "12Y", "12YQ1", "12YC", 
# 	"12YQ2", "13Y", "14Y","FS14Y","FL14Y","16Y", "18Y", 
# 	 "FL20Y", "FL30Y")
sorted_vector2 <- c("SDGB",
									 "1Y", "4Y", "6Y", "8Y", "9Y", 
									  "12Y", "14Y","16Y", "18Y", 
									 "FL20Y", "FL30Y")

sorted_vector1 <- c(
	"2017-7-GE", "2017-7-RGA", "2017-7-RGB", "2017-7-RGC", "2017-7-CG", 
	"2017-8-GE", "2017-8-RGA", "2017-8-RGB", "2017-8-RGC", "2017-8-CG", 
	"2017-9-GE", "2017-9-RGA", "2017-9-RGB", "2017-9-RGC", "2017-9-CG"
)

for (i in c("b1_sorted","b2_sorted","b3","b4")){
	group0 = read.table(paste0("../metadata_bac_",i,".txt"),sep="\t",
											header = T)
	group1 = group[group$Sample %in% group0$Sample,]
	
	if(i == "b1_sorted"){
		rownames(group1) = group1$Sample
		rownames(group0) = group0$Sample
		group1 = group1[rownames(group0),]
		group1$oldGroup = group0$oldGroup
	}
	if(i == "b2_sorted"){
		group1$oldGroup = factor(group1$oldGroup,
														 levels = sorted_vector2)
	}
	if(i == "b3"){
		group1[group1$oldGroup == "2017-8-GC","oldGroup"] = "2017-8-CG"
		group1$oldGroup = factor(group1$oldGroup,
														 levels = sorted_vector1)
	}
	group1_sorted <- group1[order(group1$oldGroup), ]
	
p[[i]] = ggboxplot(group1, x = 'oldGroup', y = 'AVD', fill = 'oldGroup', 
				palette = viridis(length(unique(group1$oldGroup))),
				color = 'gray30', width = 0.6, size = 1, legend = 'right') +
				labs(x = '', y = 'AVD', fill = '') +
				theme(legend.position = "none",
							axis.text.x = element_text(angle = 45,hjust = 1,vjust = 1)
																						)
p[[i]]

ggsave(paste0("../result/",i,"_AVD_bac.pdf"),p[[i]],width = 7,
			 height = 4)
write.csv(group[,c("Sample","AVD")],paste0("../result/",i,"_AVD_bac.csv"),
					row.names = F,quote = F)
write.csv(group1_sorted[,!colnames(group1_sorted) %in% "AVD"],
					paste0("../result/",i,"_metadata_sorted_bac.csv"),
					row.names = F,quote = F)
	
}
```